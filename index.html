<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>EPS Chart</title>
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<style>
body {
  margin: 10px;
  font-family: sans-serif;
  display: flex;
  flex-direction: column;
  height: 100vh;
}
canvas {
  width: 100% !important;
  height: auto !important;
  max-height: 200px;
}
#searchBox {
  margin-top: 15px;
  margin-bottom: 5px;
  padding: 6px;
  width: 100%;
  max-width: 300px;
  font-size: 14px;
}
#epsTableContainer {
  flex: 1;
  overflow-x: auto;
  overflow-y: auto;
  -webkit-overflow-scrolling: touch;
  margin-top: 10px;
}
table {
  border-collapse: collapse;
  font-size: 14px;
  table-layout: auto;
  min-width: max-content;
}
th, td {
  border: 1px solid #999;
  padding: 6px 8px;
  text-align: right;
  white-space: nowrap;
}
th {
  background: #f0f0f0;
  position: sticky;
  top: 0;
  z-index: 2;
}

/* Symbol列 固定＆グレー背景 */
th:first-child,
td.symbol-cell {
  position: sticky;
  left: 0;
  z-index: 3;
  background: #e0e0e0;
  text-align: left;
  cursor: pointer;
  color: blue;
  text-decoration: underline;
}

h2 { font-size: 18px; margin-bottom: 8px; }
@media (max-width: 600px) {
  table { font-size: 14px; }
  th, td { padding: 5px 6px; }
  #searchBox { font-size: 14px; padding: 6px; }
  h2 { font-size: 16px; }
}
</style>
</head>
<body>
<h2>EPS Chart</h2>

<canvas id="epsPriceChart"></canvas>

<input type="text" id="searchBox" placeholder="銘柄検索...">

<div id="epsTableContainer"></div>

<script>
// ==== ファイル名設定 ====
const files = { 
    eps: "epstrend_0q.csv",   // 四半期EPS
    price: "epstrend_0y.csv", // 年次EPSまたは株価
    calendar: "calendar.csv"  // カレンダー情報
};

let dataAll = { eps: {}, price: {}, calendar: {} };
let dateLabels = [];
let calendarHeader = [];
let currentSymbol = null;

// ==== 日付フォーマット ====
function formatDate(dateStr) {
    return dateStr ? dateStr.replace(/^20\d{2}-/, '') : '';
}

// ==== 通常CSV読み込み ====
function loadCSV(url) {
    return fetch(url).then(res => res.text())
        .then(text => {
            const rows = text.trim().split("\n").map(r => r.split(","));
            const header = rows[0].slice(1).map(formatDate);
            const data = {};
            rows.slice(1).forEach(row => {
                const symbol = row[0];
                data[symbol] = row.slice(1).map(v => v === "" ? null : v);
            });
            return { header, data };
        });
}

// ==== カレンダーCSV読み込み ====
function loadCalendarCSV(url) {
    return fetch(url).then(res => res.text())
        .then(text => {
            const rows = text.trim().split("\n").map(r => r.split(","));
            calendarHeader = rows[0].slice(1);
            const data = {};
            rows.slice(1).forEach(row => {
                const symbol = row[0];
                data[symbol] = row.slice(1);
            });
            return data;
        });
}

// ==== データ読み込み ====
Promise.all([
    loadCSV(files.eps), 
    loadCSV(files.price), 
    loadCalendarCSV(files.calendar)
]).then(([epsData, priceData, calendarData]) => {
    dateLabels = epsData.header;
    dataAll.eps = epsData.data;
    dataAll.price = priceData.data;
    dataAll.calendar = calendarData;

    const firstSymbol = Object.keys(dataAll.eps)[0];
    updateChart(firstSymbol);
    createEpsTable();
});

let epsPriceChart;

// ==== グラフ更新 ====
function updateChart(symbol) {
    currentSymbol = symbol;
    if (epsPriceChart) epsPriceChart.destroy();

    epsPriceChart = new Chart(document.getElementById("epsPriceChart"), {
        type: "line",
        data: {
            labels: dateLabels,
            datasets: [
                { label: `Qusater`, data: dataAll.eps[symbol].map(v => parseFloat(v)), borderColor: "blue", fill: false, yAxisID: 'y1' },
                { label: `Year`, data: dataAll.price[symbol].map(v => parseFloat(v)), borderColor: "green", fill: false, yAxisID: 'y2' }
            ]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            layout: { padding: { top: 30 } },
            scales: {
                y1: { type: 'linear', position: 'left', title: { display: true, text: 'Quater' } },
                y2: { type: 'linear', position: 'right', title: { display: true, text: 'Year' }, grid: { drawOnChartArea: false } }
            },
            plugins: {
                legend: { labels: { font: { size: 12 } } }
            }
        },
        plugins: [{
            id: 'symbolLabel',
            afterDraw: (chart) => {
                if (!currentSymbol) return;
                const ctx = chart.ctx;
                ctx.save();
                ctx.font = 'bold 16px sans-serif';
                ctx.fillStyle = 'black';
                ctx.textAlign = 'center';
                ctx.fillText(`Symbol: ${currentSymbol}`, chart.width/2, 20);
                ctx.restore();
            }
        }]
    });
}

// ==== テーブル生成 ====
function createEpsTable() {
    const container = document.getElementById("epsTableContainer");
    container.innerHTML = "";

    const table = document.createElement("table");
    const thead = document.createElement("thead");
    const tbody = document.createElement("tbody");

    const headerRow = document.createElement("tr");
    const thSymbol = document.createElement("th");
    thSymbol.textContent = "Symbol";
    headerRow.appendChild(thSymbol);

    calendarHeader.forEach(colName => {
        const th = document.createElement("th");
        th.textContent = colName;
        headerRow.appendChild(th);
    });

    dateLabels.slice().reverse().forEach(date => {
        const th = document.createElement("th");
        th.textContent = date;
        headerRow.appendChild(th);
    });
    thead.appendChild(headerRow);

    Object.keys(dataAll.eps).forEach(symbol => {
        const row = document.createElement("tr");

        const tdSymbol = document.createElement("td");
        tdSymbol.textContent = symbol;
        tdSymbol.classList.add("symbol-cell");
        tdSymbol.addEventListener("click", () => updateChart(symbol));
        row.appendChild(tdSymbol);

        if (dataAll.calendar[symbol]) {
            dataAll.calendar[symbol].forEach(val => {
                const td = document.createElement("td");
                td.textContent = val || "";
                td.style.textAlign = "center";
                row.appendChild(td);
            });
        } else {
            calendarHeader.forEach(() => {
                const td = document.createElement("td");
                td.textContent = "";
                row.appendChild(td);
            });
        }

        // EPS列の色付け（右列と比較）
        const epsValues = [...dataAll.eps[symbol]].reverse().map(v => v !== null && !isNaN(v) ? parseFloat(v) : null);

        epsValues.forEach((val, i) => {
            const td = document.createElement("td");
            td.textContent = val !== null ? val.toFixed(2) : "";

            if (val !== null && i < epsValues.length - 1) {
                const nextVal = epsValues[i + 1];
                if (nextVal !== null) {
                    if (val > nextVal) td.style.color = "green";
                    else if (val < nextVal) td.style.color = "red";
                }
            }
            row.appendChild(td);
        });

        tbody.appendChild(row);
    });

    table.appendChild(thead);
    table.appendChild(tbody);
    container.appendChild(table);

    const searchBox = document.getElementById("searchBox");
    searchBox.addEventListener("input", () => {
        const keyword = searchBox.value.toLowerCase();
        Array.from(tbody.getElementsByTagName("tr")).forEach(tr => {
            const symbol = tr.cells[0].textContent.toLowerCase();
            tr.style.display = symbol.includes(keyword) ? "" : "none";
        });
    });
}
</script>
</body>
</html>